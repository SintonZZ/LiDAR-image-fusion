# LiDAR-Image-Fusion: 点云与影像融合投影工具

这是一个基于 Python 的摄影测量工具，用于将 3D LiDAR 点云数据（.las/.laz）精确投影并融合到 2D 遥感影像上。

该脚本实现了从源坐标系到目标坐标系的转换、共线方程解算、深度可视化渲染，最终生成带有深度颜色信息的融合图像。

## 📌 主要功能

*   **多格式支持**: 支持读取 `.laz` (压缩格式) 和 `.las` 点云文件。
*   **坐标系转换**: 内置 `pyproj`，支持不同 EPSG 坐标系之间的转换（如从 WGS84 UTM 转换至 CGCS2000 地方坐标系）。
*   **摄影测量投影**: 基于针孔相机模型，利用相机内参（焦距、像元大小、主点偏移）和外参（位置、旋转矩阵）进行精确投影。
*   **深度可视化**: 根据点云到相机的距离，使用热力图（Jet Color Map）对投影点进行着色（近红远蓝）。
*   **遮挡剔除**: 自动剔除相机背后的点。

## 🛠️ 环境依赖

在运行脚本之前，请确保安装了以下 Python 库：

```bash
pip install numpy opencv-python pyproj laspy[lazrs]
```
*注意：强烈建议安装 `laspy[lazrs]` 以支持 `.laz` 压缩格式的快速读取。*

## ⚙️ 参数配置

在使用前，您**必须**修改脚本中 `1. 参数配置区域` 的变量以匹配您的数据。

### 1. 文件路径
| 变量名 | 说明 | 示例 |
| :--- | :--- | :--- |
| `LAS_FILE_PATH` | 点云文件路径 | `"data/2022.laz"` |
| `IMG_FILE_PATH` | 原始影像路径 | `"data/image.jpg"` |
| `OUTPUT_PATH` | 结果输出路径 | `"result/fusion.jpg"` |

### 2. 坐标系统
| 变量名 | 说明 | 示例 |
| :--- | :--- | :--- |
| `SRC_EPSG` | **点云**的坐标系代码 | `32650` (UTM Zone 50N) |
| `DST_EPSG` | **影像/相机**所在的坐标系代码 | `4549` (CGCS2000 Zone 40) |

> **注意**: 如果点云和相机本身就在同一个坐标系下，请将这两个值设为相同，或者修改代码跳过 `transformer.transform` 步骤。

### 3. 相机内参 (Intrinsics)
| 变量名 | 说明 | 单位 |
| :--- | :--- | :--- |
| `F_MM` | 焦距 | 毫米 (mm) |
| `PIXEL_SIZE` | 像元大小 | 毫米 (mm) |
| `SENSOR_CX_OFFSET` | 像主点 X 偏移 (通常为0) | 毫米 (mm) |
| `SENSOR_CY_OFFSET` | 像主点 Y 偏移 | 毫米 (mm) |
| `IMG_WIDTH` / `HEIGHT` | 影像的像素宽度和高度 | 像素 (px) |

### 4. 相机外参 (Extrinsics)
需要在目标坐标系（如 CGCS2000）下的精确数值。

*   **`CAMERA_POS`**: 相机中心坐标 `[X, Y, Z]`。
*   **`CAMERA_ROT`**: 世界坐标系到相机坐标系的旋转矩阵 $R$ (3x3)。
    *   *提示*: 确保旋转矩阵的定义方向正确（World -> Camera 还是 Camera -> World）。本脚本使用的是 `P_cam = R * (P_world - T)`。

## 🚀 运行方法

配置好参数后，直接运行 Python 脚本：

```bash
python fusion_script.py
```

## 📝 算法流程说明

1.  **数据加载**: 读取 `.laz` 点云和 `.jpg` 影像。
2.  **坐标转换**: 使用 `pyproj` 将点云从源坐标系（如 UTM）转换到相机所在的目标坐标系（如 CGCS2000）。
3.  **坐标变换**:
    *   平移：将世界坐标系原点移至相机中心 ($P_{local} = P_{world} - T$)。
    *   旋转：将点旋转至相机坐标系 ($P_{cam} = R \times P_{local}$)。
4.  **透视投影**:
    *   计算物理成像平面坐标 ($x = f \cdot \frac{X}{Z}, y = f \cdot \frac{Y}{Z}$)。
    *   转换为像素坐标 ($u, v$)，并考虑主点偏移。
5.  **过滤与绘制**:
    *   剔除落在图像范围之外的点。
    *   计算深度并归一化，应用伪彩色映射。
    *   在影像上绘制圆形标记点。

## ⚠️ 常见问题 (Troubleshooting)

*   **内存溢出 (Memory Error)**:
    *   如果影像分辨率极大（如 20000x20000），`cv2.imread` 可能失败或耗尽内存。建议使用 `cv2.resize` 缩小处理，或使用 `gdal` 分块读取。
*   **投影错位**:
    *   **检查 EPSG**: 确保点云转换后的坐标与相机坐标在同一基准下。
    *   **检查旋转矩阵**: 这是一个常见的错误源。确认您的矩阵是 `World->Camera` 还是 `Camera->World`（如果是后者，代码中需使用转置或逆矩阵）。
    *   **检查 Y 轴方向**: 图像坐标系通常 Y 轴向下，而物理坐标系 Y 轴向上。脚本中已包含 `v = cy - ...` 的处理，请根据实际情况微调。
*   **读取 LAZ 失败**:
    *   报错 `laspy` 相关错误时，请确保安装了后端支持：`pip install "laspy[lazrs]"`。

## 📜 许可证

MIT License (根据您的实际情况修改)
